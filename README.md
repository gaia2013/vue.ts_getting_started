# vue-ts-practice

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).


# memo

コンポーネントはプロパティを変更してはいけない。
￼
@Emit アノテーションが設定されたメソッドはイベントとして見なされます。
つまり、このメソッドを呼ぶことでイベントが発火されるようになります。

発火されたメソッドは上位コンポーネントで @clicked='callbackMethod'という形でイベントハンドラの登録を行います。

通常のボタンなどのイベントハンドラと同じで、登録されたメソッドはイベントが発生したときに（下位コンポーネントでメソッドが呼ばれたときに）実行されます。


Property-event-parenthood

プロパティとイベントと親子関係
上位コンポーネントから下位コンポーネントへデータを伝える場合はプロパティによるデータバインディングで伝えます。 下位コンポーネントから上位コンポーネントへデータを伝える場合はイベントを利用します。

もしも下位コンポーネントが上位コンポーネントの値を書き換えてもよいというルールにすると、上位コンポーネントは下位コンポーネントによるデータ変更を常に考慮しなくてはいけなくなります。

そもそもの問題は「不意に」データが変更されてしまう点です。 逆に言えば「意識して」データが変更されてしまう分には問題がありません。

それを達成するにはコンポーネント自身が「ここにバインドされた値はコンポーネントが変更することがあるぞ」と主張すれば問題ないのではないでしょうか。

これを vue.js ではモデルバインドという機能で実現します。

モデルバインドをする場合はこのようにvalueというプロパティとinputというイベントを定義しなくてはなりません。

このコンポーネントは「モデルバインドをしたときにバインドした値は書き換えられる」というルールを主張していることになるので、あとは使う側がそれを意識すればよいだけのことです。 逆にこういった記述がない場合は、変更されることを想定する必要はありません。

とはいえ実はこの設定はコンパイルエラーではなくワーニングになるだけなので余り頼りにならなかったりします。

￼

個人的な意見ですが、コンポーネントを触るときはなるべくライトに触ってみたかったりします。 なんとなく触ってみてよさそうだったらもう少し使い込んでみる、といったような感じで。 そういった人からするとなるべく必須項目は少なく動作してくれると嬉しかったりはします。
どうすればライトなリセットボタンになるでしょうか。


vue のコンポーネントにはライフサイクルがあります。 そのコンポーネントが生まれてから不要になるまで、つまり生まれてから死ぬまで＝ライフサイクルです。
例えばHome.vueは / にアクセスすると生成され、他の url に遷移すると破棄されます。
コンポーネントを作っていると生まれた瞬間や破壊される瞬間に処理を挟みたい場合があります。
その処理を挟む方法として処理を Hook するライフサイクルフックという機能があります。

コンポーネントが「生成された瞬間」をライフサイクルフックしてみましょう。
￼
￼
￼

ライフサイクルフックについて詳しく知りたい場合は vue.js 公式をご参考ください。
https://jp.vuejs.org/v2/guide/instance.html#%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB%E3%83%95%E3%83%83%E3%82%AF



ルーティングのフック
ルーティングが変更されたときのフックもあります。 もしもコンポーネントでルーティングをフックしたい場合は

Component.registerHooks([
  'beforeRouteEnter'
])

と記述をしてbeforeRouteEnterメソッドを定義する必要があります。
例えば描画する前にデータを取ってきて、そのデータ如何によってルーティングを変更したい時などに利用されます。 詳しくはこちらをご覧ください。 https://nrslib.com/vuejs_beforerouteenter/
まとめ
データを取得してからコンポーネントを描画したいなら beforeRouteEnter で Hook します。 コンポーネントを描画してからデータを取得したいなら create で Hook します。 typescript で beforeRouteEnter を使うときは Component.registerHook をする必要があります。


v-if という書き方でその DOM 要素を表示非表示させることができます


@Watch は文字列で指定されたフィールドやプロパティを監視し、その値が変更されるたびに設定されたメソッドを呼び出します。
何かの値に紐づけて、振る舞いを実行したい場合に利用してください。


コンポーネントに class を設定すると直下の DOM 要素に class が設定されます

もし直下の DOM 要素に class が設定されていた場合はマージされるので問題ないです。
